<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Email Trail Cleaner with OCR</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      background: #f5f5f5;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    .input-section {
      margin-bottom: 20px;
    }
    .paste-area {
      border: 2px dashed #ccc;
      padding: 20px;
      text-align: center;
      margin-bottom: 10px;
      border-radius: 4px;
      background: #fafafa;
    }
    .paste-area.dragover {
      border-color: #007cba;
      background: #e3f2fd;
    }
    /* Rich editor */
    #editor {
      min-height: 240px;
      text-align: left;
      font-family: Arial, sans-serif;
      font-size: 14px;
      overflow: auto;
    }
    #editor:empty:before {
      content: 'Paste email here (Ctrl+V). Inline images will show and be OCR’d automatically.';
      color: #888;
    }
    #editor img {
      max-width: 100%;
      height: auto;
      display: inline-block;
    }
    .ocr-text {
      margin: 6px 0 10px 0;
      padding: 6px 8px;
      background: #f0f7ff;
      border-left: 3px solid #007cba;
      white-space: pre-wrap;
      font-family: monospace;
      font-size: 12px;
    }
    textarea {
      width: 100%;
      box-sizing: border-box;
      font-family: monospace;
      font-size: 12px;
      border: 1px solid #ccc;
      border-radius: 4px;
      padding: 8px;
    }
    .button-group {
      margin: 10px 0;
    }
    button {
      padding: 8px 16px;
      margin-right: 10px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    .btn-primary {
      background: #007cba;
      color: white;
    }
    .btn-secondary {
      background: #6c757d;
      color: white;
    }
    .btn-success {
      background: #28a745;
      color: white;
    }
    .copy-options {
      display: none;
      margin-top: 10px;
    }
    .copy-chunk-btn {
      background: #17a2b8;
      color: white;
      margin: 2px;
      font-size: 12px;
      padding: 6px 12px;
    }
    .ocr-status {
      margin: 10px 0;
      padding: 8px;
      border-radius: 4px;
      display: none;
    }
    .ocr-processing {
      background: #fff3cd;
      color: #856404;
    }
    .ocr-success {
      background: #d4edda;
      color: #155724;
    }
    .ocr-error {
      background: #f8d7da;
      color: #721c24;
    }
    .img-note {
      display: inline-block;
      margin: 4px 0 8px 0;
      padding: 4px 6px;
      font-size: 12px;
      color: #555;
      background: #fff8e1;
      border-left: 3px solid #ffb300;
    }
  </style>
</head>
<body>
  <div class="container">
    <h2>Email Trail Cleaner with OCR</h2>
    
    <div class="input-section">
      <div class="paste-area" id="editor" contenteditable="true"></div>
      <div class="ocr-status" id="ocrStatus"></div>
      <textarea id="input" rows="10" style="display:none" placeholder="(synced plain text from editor)"></textarea>
    </div>

    <div class="button-group">
      <button class="btn-primary" id="cleanBtn">Clean Email</button>
      <button class="btn-secondary" id="clearBtn">Clear</button>
      <button class="btn-secondary" id="ocrAllBtn" title="Run OCR on all images in the editor">Run OCR on images</button>
    </div>

    <div class="button-group">
      <label style="display:inline-flex; align-items:center; gap:8px;">
        <input type="checkbox" id="autoOcrToggle" />
        Auto OCR on paste (may be slow/inaccurate). Use manual OCR if unchecked.
      </label>
    </div>

    <div class="button-group">
      <button class="btn-success" id="copyBtn">Copy Output</button>
      <button class="btn-secondary" id="showChunksBtn">Show Copy Chunks</button>
      <button class="btn-secondary" id="downloadBtn">Download .txt</button>
    </div>

    <div class="copy-options" id="copyOptions">
      <div id="chunkButtons"></div>
    </div>

    <div>
      <label for="output"><strong>Cleaned Output:</strong></label>
      <textarea id="output" rows="18" readonly></textarea>
    </div>
  </div>

  <!-- Include Tesseract.js from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tesseract.js/4.1.1/tesseract.min.js"></script>

<script>
/* ---------- helpers ---------- */
function normalizeSpaces(s) {
  return s.replace(/\r\n/g, '\n')
          .replace(/[ \t]+/g, ' ')
          .replace(/\s+\n/g, '\n')
          .replace(/\n{3,}/g, '\n\n');
}
function normalizeForCompare(s) {
  return s.toLowerCase().replace(/\s+/g, ' ').replace(/[^\p{L}\p{N}@\- ]+/gu, '').trim();
}
function emailToDisplayName(email) {
  const left = (email || '').split('@')[0];
  const parts = left.split(/[._\-]+/).filter(Boolean);
  if (!parts.length) return left;
  return parts.map(p => p.length === 1 ? p.toUpperCase() : p[0].toUpperCase()+p.slice(1).toLowerCase()).join(' ');
}
function cleanAngleBracketsNames(text) {
  return text.replace(/([^<\n>]+)<[^>\n]+>/g, (_, p1) => p1.trim());
}
function convertBareEmailsToNames(val) {
  return val.replace(/\b([A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,})\b/g, (m) => emailToDisplayName(m));
}
function splitHeaderBody(text) {
  const lines = text.split('\n');
  let end = -1;
  for (let i = 0; i < lines.length; i++) {
    const l = lines[i];
    if (/^\s*(From|Sent|To|Cc|Subject):/i.test(l)) {
      end = i;
      continue;
    }
    if (end >= 0) {
      if (!l.trim()) end = i;
      break;
    } else {
      break;
    }
  }
  if (end < 0) return { header: '', body: text };
  return {
    header: lines.slice(0, end + 1).join('\n').trim(),
    body: lines.slice(end + 1).join('\n')
  };
}
function breakRunOnSentences(s) {
  return s.split('\n').map(line => {
    const t = line.trim();
    if (t.length > 140 && /[.!?].+[.!?]/.test(t)) {
      return t.replace(/([.!?])\s+(?=[A-Z@])/g, '$1\n');
    }
    return line;
  }).join('\n');
}
function dedupeLinesKeepLast(body) {
  const lines = body.split('\n');
  const seen = new Set();
  const kept = [];
  for (let i = lines.length - 1; i >= 0; i--) {
    const L = lines[i];
    const t = L.trim();
    if (!t) { kept.push(L); continue; }
    const norm = normalizeForCompare(t);
    if (!norm) continue;
    if (!seen.has(norm)) {
      seen.add(norm);
      kept.push(L);
    }
  }
  kept.reverse();
  return kept.join('\n').replace(/\n{3,}/g, '\n\n');
}
function formatNumericList(body) {
  return body.replace(/^\s*(\d+)[\t ]+([^\n]+)$/gm, (m, n, rest) => `${n}. ${rest.trim()}`);
}
function cleanSignOff(body) {
  const lines = body.split('\n');
  const out = [];
  const signRx = /^(Kind regards|Best regards|Regards|Thanks|Thank you)\s*,?\s*$/i;
  let keepNextName = false;
  for (let i = 0; i < lines.length; i++) {
    const L = lines[i];
    if (keepNextName) {
      const t = L.trim();
      if (t) {
        out.push(t);
        let j = i + 1, dropped = 0;
        while (j < lines.length && dropped < 3) {
          const t2 = (lines[j] || '').trim();
          if (!t2) { j++; dropped++; continue; }
          if (/\b(Engineer|Manager|Director|Lead|Officer|Coordinator|Specialist|Department|Division|Solutions|Technology|Information|Corporate|ICT|IT|Consultant|Analyst|Support|Team)\b/i.test(t2)) {
            j++; dropped++; continue;
          }
          break;
        }
        i = j - 1;
      }
      keepNextName = false;
      continue;
    }
    if (signRx.test(L.trim())) {
      if (out.length && out[out.length - 1].trim() !== '') out.push('');
      out.push(L.trim().replace(/,?$/, ','));
      keepNextName = true;
      continue;
    }
    out.push(L);
  }
  return out.join('\n').replace(/\n{3,}/g, '\n\n');
}

/* ---------- main cleaner ---------- */
function cleanEmailTrail(raw) {
  if (!raw) return '';
  let text = normalizeSpaces(raw);

  text = text.replace(/^\s*C\d+\s*Controlled.*\n?/gmi, '');
  text = text.replace(/^\s*CLASSIFICATION\s*:\s*.*$/gmi, '');
  text = text.replace(/^\s*CLASSIFICATION\s*:\s*C?\d+\s*[-–—]?\s*CONTROLLED\s*/gmi, '');
  text = text.replace(/^[A-Za-z0-9+/=]{8,}.*BannerStart[\s\S]*?BannerEnd.*\n?/gmi, '');
  text = text
    .replace(/^\s*\[EXTERNAL\][^\n]*\n?/gmi, '')
    .replace(/^\s*EXTERNAL:\s.*\n?/gmi, '')
    .replace(/^\s*This message originated.*\n?/gmi, '');
  text = text.replace(/^\s*Subject:.*\n?/gmi, '');
  text = cleanAngleBracketsNames(text);

  const split = splitHeaderBody(text);
  let header = split.header || '';
  let body = split.body || '';

  header = header
    .replace(/^(From|Sent|To|Cc):\s*(.*)$/gmi, (m, label, val) => {
      val = convertBareEmailsToNames(val);
      val = val.replace(/\s*;\s*/g, '; ').replace(/\s{2,}/g, ' ').trim();
      return `${label}: ${val}`;
    })
    .replace(/^\s*Cc:.*\n?/gmi, '')
    .trim();

  body = body.replace(/^\s*CLASSIFICATION\s*:\s*.*$/gmi, '');
  body = body.replace(/^\s*[-–—]\s*/gm, '- ')
             .replace(/^\s*_{5,}.*\n?/gm, '')
             .replace(/^\s*-{5,}.*\n?/gm, '');

  const footerLineRx = [
    /you.?re receiving emails?/i,
    /you are receiving this email/i,
    /to (?:change|update|manage|turn off).*email/i,
    /\bunsubscribe\b/i,
    /\bmanage (?:your )?(?:preferences|subscriptions)\b/i,
    /\bemail preferences\b/i,
    /\bprivacy policy\b/i,
    /\bterms of service\b/i,
    /\bview in (?:your )?browser\b/i
  ];
  footerLineRx.forEach(rx => {
    body = body.replace(new RegExp(`^.*${rx.source}.*$`, 'gmi'), '');
  });

  const disclaimerLineRx = [
    /^This e-?mail and any attachments are confidential/i,
    /^This email and any attachments are confidential/i,
    /^The information (?:in|contained in) this e-?mail is confidential/i,
    /confidential.*legally privileged/i,
    /^If you are not the addressee/i,
    /^If you are not the intended recipient/i,
    /you may not copy, forward, disclose/i,
    /delete the original and any printout/i,
    /any disclosure, copying, distribution/i,
    /no (?:liability|responsibility) whatsoever/i,
    /whilst all reasonable steps are taken/i,
    /virus.*(computer|software)/i
  ];
  disclaimerLineRx.forEach(rx => {
    body = body.replace(new RegExp(rx.source, 'gmi'), (m) => '');
  });
  body = body.replace(/^\s*($)/gmi, '');

  body = body.replace(
    /^\s*(This e-?mail.*confidential[\s\S]*?)(?=\n\s*\n|$)/gmi, ''
  ).replace(
    /^\s*(The information.*confidential[\s\S]*?)(?=\n\s*\n|$)/gmi, ''
  );

  const signatureRx = new RegExp([
    /^(?:tel(?:ephone)?|phone|fax|office|mobile|direct|switchboard|website|web|site|email)\s*:.*$/i.source,
    /^(?:p|m|t|f|e|w)\.?\s*[\+:0-9].*$/i.source,
    /^[\s\+()0-9-]{8,}$/i.source,
    /^.*\b(?:https?:\/\/|www\.)\S*$/i.source,
    /^\s*[A-Za-z0-9.-]+\.[A-Za-z]{2,}(?:\/\S*)?\s*$/i.source,
    /^\s*[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}\s*$/i.source
  ].join('|'), 'gmi');
  body = body.replace(signatureRx, '');

  body = body.replace(/^\s*ID\s+Request\s+.*Subsidiary.*$/gmi, '');
  body = body.replace(/\s+,/g, ',');
  body = breakRunOnSentences(body);
  body = formatNumericList(body);
  body = dedupeLinesKeepLast(body);
  body = body.replace(/\b(Hi|Hello|Dear)\s+([^\n,]+),?/i, (m, g1, g2) => `${g1} ${g2},\n\n`);
  body = cleanSignOff(body);
  body = normalizeSpaces(body).trim();

  const out = [header, body].filter(Boolean).join('\n\n').trim();
  return out;
}

/* ---------- OCR functions ---------- */
function showOcrStatus(message, type) {
  const statusEl = document.getElementById('ocrStatus');
  statusEl.textContent = message;
  statusEl.className = `ocr-status ocr-${type}`;
  statusEl.style.display = 'block';
}

function hideOcrStatus() {
  document.getElementById('ocrStatus').style.display = 'none';
}

async function processImageWithOCR(file) {
  showOcrStatus('Processing image with OCR...', 'processing');
  
  try {
    const { data: { text } } = await Tesseract.recognize(file, 'eng', {
      logger: m => {
        if (m.status === 'recognizing text') {
          showOcrStatus(`OCR Progress: ${Math.round(m.progress * 100)}%`, 'processing');
        }
      }
    ,
      tessedit_char_blacklist: "{}[]<>~`^|",
      // PSM 6: Assume a single uniform block of text
      // You can tweak to 3 or 4 depending on your samples
      psm: 6
    });
    
    if (text.trim()) {
      showOcrStatus('OCR completed successfully!', 'success');
      setTimeout(hideOcrStatus, 3000);
      return text;
    } else {
      showOcrStatus('No text found in image', 'error');
      setTimeout(hideOcrStatus, 3000);
      return '';
    }
  } catch (error) {
    showOcrStatus('OCR failed: ' + error.message, 'error');
    setTimeout(hideOcrStatus, 5000);
    return '';
  }
}

function isImageFile(file) {
  return file && file.type && file.type.startsWith('image/');
}

// Preprocess image for better OCR: upscale, grayscale, increase contrast, binarize
async function preprocessImageToBlob(imgOrBlob) {
  return new Promise(async (resolve, reject) => {
    try {
      let imgEl;
      if (imgOrBlob instanceof Blob) {
        const url = URL.createObjectURL(imgOrBlob);
        imgEl = new Image();
        imgEl.crossOrigin = 'anonymous';
        imgEl.onload = () => {
          URL.revokeObjectURL(url);
          resolve(processElement(imgEl));
        };
        imgEl.onerror = () => {
          URL.revokeObjectURL(url);
          reject(new Error('Image load failed'));
        };
        imgEl.src = url;
      } else {
        imgEl = imgOrBlob;
        if (imgEl.complete && imgEl.naturalWidth) {
          resolve(processElement(imgEl));
        } else {
          imgEl.onload = () => resolve(processElement(imgEl));
          imgEl.onerror = () => reject(new Error('Image load failed'));
        }
      }

      function processElement(img) {
        const scale = 2; // 2x upscale improves small text
        const w = Math.max(1, Math.floor(img.naturalWidth * scale));
        const h = Math.max(1, Math.floor(img.naturalHeight * scale));
        const canvas = document.createElement('canvas');
        canvas.width = w;
        canvas.height = h;
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';
        ctx.drawImage(img, 0, 0, w, h);
        // Grayscale + simple contrast/threshold
        const imgData = ctx.getImageData(0, 0, w, h);
        const data = imgData.data;
        // Compute simple adaptive threshold baseline
        let sum = 0;
        for (let i = 0; i < data.length; i += 4) {
          const gray = 0.2126 * data[i] + 0.7152 * data[i+1] + 0.0722 * data[i+2];
          sum += gray;
        }
        const mean = sum / (data.length / 4);
        const threshold = Math.min(255, Math.max(0, mean + 10));
        for (let i = 0; i < data.length; i += 4) {
          const gray = 0.2126 * data[i] + 0.7152 * data[i+1] + 0.0722 * data[i+2];
          const v = gray > threshold ? 255 : 0;
          data[i] = data[i+1] = data[i+2] = v;
          data[i+3] = 255;
        }
        ctx.putImageData(imgData, 0, 0);
        return new Promise((res) => canvas.toBlob((b) => res(b), 'image/png'));
      }
    } catch (err) {
      reject(err);
    }
  });
}

async function getImageBlobForOCR(imgEl) {
  try {
    const src = imgEl.getAttribute('src') || '';
    if (src.startsWith('blob:') || src.startsWith('data:')) {
      // Can be drawn to canvas safely
      const pre = await preprocessImageToBlob(imgEl);
      return pre;
    }
    // Try fetch if CORS allows
    const resp = await fetch(src, { mode: 'cors' });
    if (!resp.ok) throw new Error('fetch failed');
    const blob = await resp.blob();
    return await preprocessImageToBlob(blob);
  } catch (e) {
    return null; // Unavailable (e.g., cid:, blocked CORS)
  }
}

/* ---------- Copy chunks ---------- */
function createChunkButtons(text) {
  const chunkSize = 8000;
  const chunks = [];
  for (let i = 0; i < text.length; i += chunkSize) {
    chunks.push(text.substring(i, i + chunkSize));
  }
  
  const container = document.getElementById('chunkButtons');
  container.innerHTML = '';
  
  if (chunks.length <= 1) {
    container.innerHTML = '<p>Text is small enough for single copy</p>';
    return;
  }
  
  chunks.forEach((chunk, index) => {
    const btn = document.createElement('button');
    btn.className = 'copy-chunk-btn';
    btn.textContent = `Copy chunk ${index + 1} (${chunk.length} chars)`;
    btn.onclick = async () => {
      try {
        await navigator.clipboard.writeText(chunk);
        btn.textContent = `✓ Copied chunk ${index + 1}`;
        setTimeout(() => {
          btn.textContent = `Copy chunk ${index + 1} (${chunk.length} chars)`;
        }, 2000);
      } catch {
        alert('Could not copy automatically. Please select and copy manually.');
      }
    };
    container.appendChild(btn);
  });
}

/* ---------- Event Handlers ---------- */
const editorEl = document.getElementById('editor');
const inputTextarea = document.getElementById('input');

function syncPlainTextFromEditor() {
  // Convert the editor's visible text (including OCR inserts) into plain text
  const text = editorEl.innerText || '';
  inputTextarea.value = text.trim();
}

function insertImageAtCaret(src) {
  const img = document.createElement('img');
  img.src = src;
  img.crossOrigin = 'anonymous';
  const sel = window.getSelection();
  if (sel && sel.rangeCount > 0) {
    const range = sel.getRangeAt(0);
    range.deleteContents();
    range.insertNode(img);
    // Move caret after image
    range.setStartAfter(img);
    range.setEndAfter(img);
    sel.removeAllRanges();
    sel.addRange(range);
  } else {
    editorEl.appendChild(img);
  }
}

async function ocrImageSrc(src, imgEl) {
  try {
    const preBlob = await getImageBlobForOCR(imgEl);
    if (!preBlob) {
      if (!imgEl.dataset.ocrMarked) {
        const note = document.createElement('div');
        note.className = 'img-note';
        note.textContent = 'Image cannot be OCR’d (cid: or blocked by CORS).';
        imgEl.insertAdjacentElement('afterend', note);
        imgEl.dataset.ocrMarked = '1';
      }
      return;
    }
    const text = await processImageWithOCR(preBlob);
    if (text && imgEl && !imgEl.dataset.ocrDone) {
      const ocrDiv = document.createElement('div');
      ocrDiv.className = 'ocr-text';
      ocrDiv.textContent = text.trim();
      imgEl.insertAdjacentElement('afterend', ocrDiv);
      imgEl.dataset.ocrDone = '1';
      syncPlainTextFromEditor();
    }
  } catch (err) {
    // ignore failures for non-fetchable sources (e.g., cid:)
  }
}

function processEditorContentAfterPaste(e) {
  // Give the browser a tick to insert pasted content
  setTimeout(async () => {
    // If clipboard included image files, insert them at caret
    const items = Array.from((e.clipboardData || {}).items || []);
    for (const item of items) {
      if (item.kind === 'file') {
        const file = item.getAsFile();
        if (isImageFile(file)) {
          const url = URL.createObjectURL(file);
          insertImageAtCaret(url);
          // OCR this image
          const lastImg = editorEl.querySelector('img:last-of-type');
          if (lastImg) {
            await ocrImageSrc(url, lastImg);
          }
        }
      }
    }

    // Optionally OCR images present that haven't been processed
    const imgs = Array.from(editorEl.querySelectorAll('img'));
    // Ensure crossOrigin to maximize CORS success
    imgs.forEach(i => { if (!i.crossOrigin) i.crossOrigin = 'anonymous'; });
    const auto = document.getElementById('autoOcrToggle');
    if (auto && auto.checked) {
      for (const img of imgs) {
        const src = img.getAttribute('src') || '';
        if (!img.dataset.ocrDone) {
          await ocrImageSrc(src, img);
        }
      }
    }

    syncPlainTextFromEditor();
  }, 0);
}

// Handle paste into the rich editor
editorEl.addEventListener('paste', (e) => {
  // Allow default HTML paste to keep formatting and inline images if available
  processEditorContentAfterPaste(e);
});

// Per-image OCR by clicking an image
editorEl.addEventListener('click', async (e) => {
  const target = e.target;
  if (target && target.tagName === 'IMG') {
    const img = target;
    if (!img.dataset.ocrDone) {
      const src = img.getAttribute('src') || '';
      await ocrImageSrc(src, img);
    }
  }
});

// Manual Run OCR on all images
document.getElementById('ocrAllBtn').addEventListener('click', async () => {
  const imgs = Array.from(editorEl.querySelectorAll('img'));
  for (const img of imgs) {
    if (!img.dataset.ocrDone) {
      const src = img.getAttribute('src') || '';
      await ocrImageSrc(src, img);
    }
  }
});

// Button handlers
document.getElementById('cleanBtn').addEventListener('click', () => {
  syncPlainTextFromEditor();
  const input = inputTextarea.value || '';
  const output = cleanEmailTrail(input);
  const outputTextarea = document.getElementById('output');
  outputTextarea.value = output;
  
  // Update chunk buttons
  createChunkButtons(output);
});

document.getElementById('clearBtn').addEventListener('click', () => {
  editorEl.innerHTML = '';
  inputTextarea.value = '';
  document.getElementById('output').value = '';
  document.getElementById('copyOptions').style.display = 'none';
  hideOcrStatus();
});

document.getElementById('copyBtn').addEventListener('click', async () => {
  const out = document.getElementById('output').value || '';
  try {
    await navigator.clipboard.writeText(out);
    alert('Clean text copied to clipboard.');
  } catch {
    alert('Could not copy automatically. Please select and copy manually.');
  }
});

document.getElementById('showChunksBtn').addEventListener('click', () => {
  const output = document.getElementById('output').value || '';
  const copyOptions = document.getElementById('copyOptions');
  
  if (copyOptions.style.display === 'none' || !copyOptions.style.display) {
    createChunkButtons(output);
    copyOptions.style.display = 'block';
    document.getElementById('showChunksBtn').textContent = 'Hide Copy Chunks';
  } else {
    copyOptions.style.display = 'none';
    document.getElementById('showChunksBtn').textContent = 'Show Copy Chunks';
  }
});

document.getElementById('downloadBtn').addEventListener('click', () => {
  const out = document.getElementById('output').value || '';
  const blob = new Blob([out], { type: 'text/plain' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'cleaned-email.txt';
  a.click();
  URL.revokeObjectURL(a.href);
});
</script>
</body>
</html>