<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Email Trail Cleaner with OCR</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      background: #f5f5f5;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    .input-section {
      margin-bottom: 20px;
    }
    .paste-area {
      border: 2px dashed #ccc;
      padding: 20px;
      text-align: center;
      margin-bottom: 10px;
      border-radius: 4px;
      background: #fafafa;
    }
    .paste-area.dragover {
      border-color: #007cba;
      background: #e3f2fd;
    }
    textarea {
      width: 100%;
      box-sizing: border-box;
      font-family: monospace;
      font-size: 12px;
      border: 1px solid #ccc;
      border-radius: 4px;
      padding: 8px;
    }
    .button-group {
      margin: 10px 0;
    }
    button {
      padding: 8px 16px;
      margin-right: 10px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    .btn-primary {
      background: #007cba;
      color: white;
    }
    .btn-secondary {
      background: #6c757d;
      color: white;
    }
    .btn-success {
      background: #28a745;
      color: white;
    }
    .copy-options {
      display: none;
      margin-top: 10px;
    }
    .copy-chunk-btn {
      background: #17a2b8;
      color: white;
      margin: 2px;
      font-size: 12px;
      padding: 6px 12px;
    }
    .ocr-status {
      margin: 10px 0;
      padding: 8px;
      border-radius: 4px;
      display: none;
    }
    .ocr-processing {
      background: #fff3cd;
      color: #856404;
    }
    .ocr-success {
      background: #d4edda;
      color: #155724;
    }
    .ocr-error {
      background: #f8d7da;
      color: #721c24;
    }
  </style>
</head>
<body>
  <div class="container">
    <h2>Email Trail Cleaner with OCR</h2>
    
    <div class="input-section">
      <div class="paste-area" id="pasteArea">
        <p><strong>Drop images here or paste email content with Ctrl+V</strong></p>
        <p>Supports: Images (PNG, JPG, GIF, WebP) for OCR extraction</p>
      </div>
      <div class="ocr-status" id="ocrStatus"></div>
      <textarea id="input" rows="18" placeholder="Email content will appear here after pasting or OCR..."></textarea>
    </div>

    <div class="button-group">
      <button class="btn-primary" id="cleanBtn">Clean Email</button>
      <button class="btn-secondary" id="clearBtn">Clear</button>
    </div>

    <div class="button-group">
      <button class="btn-success" id="copyBtn">Copy Output</button>
      <button class="btn-secondary" id="showChunksBtn">Show Copy Chunks</button>
      <button class="btn-secondary" id="downloadBtn">Download .txt</button>
    </div>

    <div class="copy-options" id="copyOptions">
      <div id="chunkButtons"></div>
    </div>

    <div>
      <label for="output"><strong>Cleaned Output:</strong></label>
      <textarea id="output" rows="18" readonly></textarea>
    </div>
  </div>

  <!-- Include Tesseract.js from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tesseract.js/4.1.1/tesseract.min.js"></script>

<script>
/* ---------- helpers ---------- */
function normalizeSpaces(s) {
  return s.replace(/\r\n/g, '\n')
          .replace(/[ \t]+/g, ' ')
          .replace(/\s+\n/g, '\n')
          .replace(/\n{3,}/g, '\n\n');
}
function normalizeForCompare(s) {
  return s.toLowerCase().replace(/\s+/g, ' ').replace(/[^\p{L}\p{N}@\- ]+/gu, '').trim();
}
function emailToDisplayName(email) {
  const left = (email || '').split('@')[0];
  const parts = left.split(/[._\-]+/).filter(Boolean);
  if (!parts.length) return left;
  return parts.map(p => p.length === 1 ? p.toUpperCase() : p[0].toUpperCase()+p.slice(1).toLowerCase()).join(' ');
}
function cleanAngleBracketsNames(text) {
  return text.replace(/([^<\n>]+)<[^>\n]+>/g, (_, p1) => p1.trim());
}
function convertBareEmailsToNames(val) {
  return val.replace(/\b([A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,})\b/g, (m) => emailToDisplayName(m));
}
function splitHeaderBody(text) {
  const lines = text.split('\n');
  let end = -1;
  for (let i = 0; i < lines.length; i++) {
    const l = lines[i];
    if (/^\s*(From|Sent|To|Cc|Subject):/i.test(l)) {
      end = i;
      continue;
    }
    if (end >= 0) {
      if (!l.trim()) end = i;
      break;
    } else {
      break;
    }
  }
  if (end < 0) return { header: '', body: text };
  return {
    header: lines.slice(0, end + 1).join('\n').trim(),
    body: lines.slice(end + 1).join('\n')
  };
}
function breakRunOnSentences(s) {
  return s.split('\n').map(line => {
    const t = line.trim();
    if (t.length > 140 && /[.!?].+[.!?]/.test(t)) {
      return t.replace(/([.!?])\s+(?=[A-Z@])/g, '$1\n');
    }
    return line;
  }).join('\n');
}
function dedupeLinesKeepLast(body) {
  const lines = body.split('\n');
  const seen = new Set();
  const kept = [];
  for (let i = lines.length - 1; i >= 0; i--) {
    const L = lines[i];
    const t = L.trim();
    if (!t) { kept.push(L); continue; }
    const norm = normalizeForCompare(t);
    if (!norm) continue;
    if (!seen.has(norm)) {
      seen.add(norm);
      kept.push(L);
    }
  }
  kept.reverse();
  return kept.join('\n').replace(/\n{3,}/g, '\n\n');
}
function formatNumericList(body) {
  return body.replace(/^\s*(\d+)[\t ]+([^\n]+)$/gm, (m, n, rest) => `${n}. ${rest.trim()}`);
}
function cleanSignOff(body) {
  const lines = body.split('\n');
  const out = [];
  const signRx = /^(Kind regards|Best regards|Regards|Thanks|Thank you)\s*,?\s*$/i;
  let keepNextName = false;
  for (let i = 0; i < lines.length; i++) {
    const L = lines[i];
    if (keepNextName) {
      const t = L.trim();
      if (t) {
        out.push(t);
        let j = i + 1, dropped = 0;
        while (j < lines.length && dropped < 3) {
          const t2 = (lines[j] || '').trim();
          if (!t2) { j++; dropped++; continue; }
          if (/\b(Engineer|Manager|Director|Lead|Officer|Coordinator|Specialist|Department|Division|Solutions|Technology|Information|Corporate|ICT|IT|Consultant|Analyst|Support|Team)\b/i.test(t2)) {
            j++; dropped++; continue;
          }
          break;
        }
        i = j - 1;
      }
      keepNextName = false;
      continue;
    }
    if (signRx.test(L.trim())) {
      if (out.length && out[out.length - 1].trim() !== '') out.push('');
      out.push(L.trim().replace(/,?$/, ','));
      keepNextName = true;
      continue;
    }
    out.push(L);
  }
  return out.join('\n').replace(/\n{3,}/g, '\n\n');
}

/* ---------- main cleaner ---------- */
function cleanEmailTrail(raw) {
  if (!raw) return '';
  let text = normalizeSpaces(raw);

  text = text.replace(/^\s*C\d+\s*Controlled.*\n?/gmi, '');
  text = text.replace(/^\s*CLASSIFICATION\s*:\s*.*$/gmi, '');
  text = text.replace(/^\s*CLASSIFICATION\s*:\s*C?\d+\s*[-–—]?\s*CONTROLLED\s*/gmi, '');
  text = text.replace(/^[A-Za-z0-9+/=]{8,}.*BannerStart[\s\S]*?BannerEnd.*\n?/gmi, '');
  text = text
    .replace(/^\s*\[EXTERNAL\][^\n]*\n?/gmi, '')
    .replace(/^\s*EXTERNAL:\s.*\n?/gmi, '')
    .replace(/^\s*This message originated.*\n?/gmi, '');
  text = text.replace(/^\s*Subject:.*\n?/gmi, '');
  text = cleanAngleBracketsNames(text);

  const split = splitHeaderBody(text);
  let header = split.header || '';
  let body = split.body || '';

  header = header
    .replace(/^(From|Sent|To|Cc):\s*(.*)$/gmi, (m, label, val) => {
      val = convertBareEmailsToNames(val);
      val = val.replace(/\s*;\s*/g, '; ').replace(/\s{2,}/g, ' ').trim();
      return `${label}: ${val}`;
    })
    .replace(/^\s*Cc:.*\n?/gmi, '')
    .trim();

  body = body.replace(/^\s*CLASSIFICATION\s*:\s*.*$/gmi, '');
  body = body.replace(/^\s*[-–—]\s*/gm, '- ')
             .replace(/^\s*_{5,}.*\n?/gm, '')
             .replace(/^\s*-{5,}.*\n?/gm, '');

  const footerLineRx = [
    /you.?re receiving emails?/i,
    /you are receiving this email/i,
    /to (?:change|update|manage|turn off).*email/i,
    /\bunsubscribe\b/i,
    /\bmanage (?:your )?(?:preferences|subscriptions)\b/i,
    /\bemail preferences\b/i,
    /\bprivacy policy\b/i,
    /\bterms of service\b/i,
    /\bview in (?:your )?browser\b/i
  ];
  footerLineRx.forEach(rx => {
    body = body.replace(new RegExp(`^.*${rx.source}.*$`, 'gmi'), '');
  });

  const disclaimerLineRx = [
    /^This e-?mail and any attachments are confidential/i,
    /^This email and any attachments are confidential/i,
    /^The information (?:in|contained in) this e-?mail is confidential/i,
    /confidential.*legally privileged/i,
    /^If you are not the addressee/i,
    /^If you are not the intended recipient/i,
    /you may not copy, forward, disclose/i,
    /delete the original and any printout/i,
    /any disclosure, copying, distribution/i,
    /no (?:liability|responsibility) whatsoever/i,
    /whilst all reasonable steps are taken/i,
    /virus.*(computer|software)/i
  ];
  disclaimerLineRx.forEach(rx => {
    body = body.replace(new RegExp(rx.source, 'gmi'), (m) => '');
  });
  body = body.replace(/^\s*($)/gmi, '');

  body = body.replace(
    /^\s*(This e-?mail.*confidential[\s\S]*?)(?=\n\s*\n|$)/gmi, ''
  ).replace(
    /^\s*(The information.*confidential[\s\S]*?)(?=\n\s*\n|$)/gmi, ''
  );

  const signatureRx = new RegExp([
    /^(?:tel(?:ephone)?|phone|fax|office|mobile|direct|switchboard|website|web|site|email)\s*:.*$/i.source,
    /^(?:p|m|t|f|e|w)\.?\s*[\+:0-9].*$/i.source,
    /^[\s\+()0-9-]{8,}$/i.source,
    /^.*\b(?:https?:\/\/|www\.)\S*$/i.source,
    /^\s*[A-Za-z0-9.-]+\.[A-Za-z]{2,}(?:\/\S*)?\s*$/i.source,
    /^\s*[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}\s*$/i.source
  ].join('|'), 'gmi');
  body = body.replace(signatureRx, '');

  body = body.replace(/^\s*ID\s+Request\s+.*Subsidiary.*$/gmi, '');
  body = body.replace(/\s+,/g, ',');
  body = breakRunOnSentences(body);
  body = formatNumericList(body);
  body = dedupeLinesKeepLast(body);
  body = body.replace(/\b(Hi|Hello|Dear)\s+([^\n,]+),?/i, (m, g1, g2) => `${g1} ${g2},\n\n`);
  body = cleanSignOff(body);
  body = normalizeSpaces(body).trim();

  const out = [header, body].filter(Boolean).join('\n\n').trim();
  return out;
}

/* ---------- OCR functions ---------- */
function showOcrStatus(message, type) {
  const statusEl = document.getElementById('ocrStatus');
  statusEl.textContent = message;
  statusEl.className = `ocr-status ocr-${type}`;
  statusEl.style.display = 'block';
}

function hideOcrStatus() {
  document.getElementById('ocrStatus').style.display = 'none';
}

async function processImageWithOCR(file) {
  showOcrStatus('Processing image with OCR...', 'processing');
  
  try {
    const { data: { text } } = await Tesseract.recognize(file, 'eng', {
      logger: m => {
        if (m.status === 'recognizing text') {
          showOcrStatus(`OCR Progress: ${Math.round(m.progress * 100)}%`, 'processing');
        }
      }
    });
    
    if (text.trim()) {
      showOcrStatus('OCR completed successfully!', 'success');
      setTimeout(hideOcrStatus, 3000);
      return text;
    } else {
      showOcrStatus('No text found in image', 'error');
      setTimeout(hideOcrStatus, 3000);
      return '';
    }
  } catch (error) {
    showOcrStatus('OCR failed: ' + error.message, 'error');
    setTimeout(hideOcrStatus, 5000);
    return '';
  }
}

function isImageFile(file) {
  return file && file.type && file.type.startsWith('image/');
}

/* ---------- Copy chunks ---------- */
function createChunkButtons(text) {
  const chunkSize = 8000;
  const chunks = [];
  for (let i = 0; i < text.length; i += chunkSize) {
    chunks.push(text.substring(i, i + chunkSize));
  }
  
  const container = document.getElementById('chunkButtons');
  container.innerHTML = '';
  
  if (chunks.length <= 1) {
    container.innerHTML = '<p>Text is small enough for single copy</p>';
    return;
  }
  
  chunks.forEach((chunk, index) => {
    const btn = document.createElement('button');
    btn.className = 'copy-chunk-btn';
    btn.textContent = `Copy chunk ${index + 1} (${chunk.length} chars)`;
    btn.onclick = async () => {
      try {
        await navigator.clipboard.writeText(chunk);
        btn.textContent = `✓ Copied chunk ${index + 1}`;
        setTimeout(() => {
          btn.textContent = `Copy chunk ${index + 1} (${chunk.length} chars)`;
        }, 2000);
      } catch {
        alert('Could not copy automatically. Please select and copy manually.');
      }
    };
    container.appendChild(btn);
  });
}

/* ---------- Event Handlers ---------- */
const pasteArea = document.getElementById('pasteArea');
const inputTextarea = document.getElementById('input');

// Paste handling
pasteArea.addEventListener('paste', async (e) => {
  e.preventDefault();
  const items = Array.from(e.clipboardData.items);
  
  for (const item of items) {
    if (item.kind === 'file' && isImageFile(item.getAsFile())) {
      const file = item.getAsFile();
      const ocrText = await processImageWithOCR(file);
      if (ocrText) {
        inputTextarea.value = (inputTextarea.value + '\n' + ocrText).trim();
      }
      return;
    }
  }
  
  // Handle text paste
  const text = e.clipboardData.getData('text/plain');
  if (text) {
    inputTextarea.value = text;
  }
});

// Global paste handling
document.addEventListener('paste', async (e) => {
  if (e.target === inputTextarea) return; // Let textarea handle its own paste
  
  e.preventDefault();
  const items = Array.from(e.clipboardData.items);
  
  for (const item of items) {
    if (item.kind === 'file' && isImageFile(item.getAsFile())) {
      const file = item.getAsFile();
      const ocrText = await processImageWithOCR(file);
      if (ocrText) {
        inputTextarea.value = (inputTextarea.value + '\n' + ocrText).trim();
      }
      return;
    }
  }
  
  const text = e.clipboardData.getData('text/plain');
  if (text) {
    inputTextarea.value = text;
  }
});

// Drag and drop - removed since we don't want file dropping
pasteArea.addEventListener('dragover', (e) => {
  e.preventDefault();
});

pasteArea.addEventListener('drop', (e) => {
  e.preventDefault();
  // No drag/drop functionality - users should copy from Outlook
});

// Button handlers
document.getElementById('cleanBtn').addEventListener('click', () => {
  const input = inputTextarea.value || '';
  const output = cleanEmailTrail(input);
  const outputTextarea = document.getElementById('output');
  outputTextarea.value = output;
  
  // Update chunk buttons
  createChunkButtons(output);
});

document.getElementById('clearBtn').addEventListener('click', () => {
  inputTextarea.value = '';
  document.getElementById('output').value = '';
  document.getElementById('copyOptions').style.display = 'none';
  hideOcrStatus();
});

document.getElementById('copyBtn').addEventListener('click', async () => {
  const out = document.getElementById('output').value || '';
  try {
    await navigator.clipboard.writeText(out);
    alert('Clean text copied to clipboard.');
  } catch {
    alert('Could not copy automatically. Please select and copy manually.');
  }
});

document.getElementById('showChunksBtn').addEventListener('click', () => {
  const output = document.getElementById('output').value || '';
  const copyOptions = document.getElementById('copyOptions');
  
  if (copyOptions.style.display === 'none' || !copyOptions.style.display) {
    createChunkButtons(output);
    copyOptions.style.display = 'block';
    document.getElementById('showChunksBtn').textContent = 'Hide Copy Chunks';
  } else {
    copyOptions.style.display = 'none';
    document.getElementById('showChunksBtn').textContent = 'Show Copy Chunks';
  }
});

document.getElementById('downloadBtn').addEventListener('click', () => {
  const out = document.getElementById('output').value || '';
  const blob = new Blob([out], { type: 'text/plain' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'cleaned-email.txt';
  a.click();
  URL.revokeObjectURL(a.href);
});
</script>
</body>
</html>